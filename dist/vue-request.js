import merge from"lodash.merge";export default{install(t,e){const o=merge({},{axiosDefaults:{timeout:12e4,retry:3,withCredentials:!0,timeoutFactor:1.5},withXHR:!0,componentName:"Loading",status:{},fallBack(){alert(this.fallBackText)},fallBackText:"Hubo un problema al comunicarse con el servicio, por favor revise su conexión o reintente más tarde",fallBackTimeOut:15e3,request:[],response:[]},e),{axios:s,axiosDefaults:r,fallBack:a,componentName:n,store:i,storeName:l}=o;if(!s)throw new Error("This plugins needs an axios instance assigned as 'axios'");o.withXHR&&(s.defaults.headers.common["X-Requested-With"]="XMLHttpRequest"),merge(s.defaults,r);const c=t=>{t.loading=!0,t.loadCount++},u=t=>{t.loadCount--,t.loadCount<=0&&(t.loadCount=0,t.loading=!1)},m={loading:!1,loadCount:0,block:!1,configs:new Map},f=new t,d=l||"request";if(i){if(i.hasModule(d))throw new Error(`vue-request has store but "${d}" already exists, plase change storeName in options`);i.registerModule(l||"request",{namespaced:!0,state:m,mutations:{start:c,stop:u,configSet(t,{key:e,config:o}){t.config.set(e,o)},configGet:(t,e)=>t.config.get(e),configDel:(t,e)=>t.config.del(e),lock(t,e){t.lock=e}}})}n&&t.component(n,(async()=>({name:n,props:{transition:{type:String,default:"fade"},color:{type:String,default:"rgba(255, 255, 255, 0.5)"}},computed:{state:()=>i?i.state[d]:m},template:'\n            <transition name={transition}>\n              <div v-show="state.loading" class="__ITDModal" :style="{\'background-color\': color}">\n                <slot>\n                  <h1>Waiting slot here</h1>\n                </slot>\n              </div>\n            </transition>'})));s.interceptors.request.use((t=>(t.noBlock||(i?i.commit(`${d}/start`):c(m)),t.try=t.try||1,t))),s.interceptors.response.use((t=>(i?i.commit(`${d}/stop`):u(m),t.body=t.data,t)),(t=>{const{config:e,response:r}=t;if(e.try++,e.timeout*=e.timeoutFactor,e.noBlock||(i?i.commit(`${d}/stop`):u(m)),r){if(r.body=r.data,`${r.status}`in o.status){if("retry"!==o.status[`${r.status}`])return o.status[r.status](e,r);if(e.try<=e.retry)return s(e)}return Promise.reject(t)}if(e.try<=e.retry)return s(e);e.try=1;let n=new Promise((t=>{const{url:o,method:s,params:r,body:a}=e;let n=`${o}${s}${JSON.stringify(r)}${JSON.stringify(a)}`;i?i.commit(`${d}/configSet`,{key:n,config:e}):m.configs.set(n,e),f.$once(n,(e=>{t(e)}))}));return(i?i.state[d].lock:m.lock)||(i?i.commit(`${d}/lock`,!0):m.lock=!0,Promise.resolve(a(t)).then((()=>{i?i.commit(`${d}/lock`,!1):m.lock=!1;let{configs:t}=i?i.state[d]:m;t.forEach(((t,e)=>{s(t).then((t=>{i?i.commit(`${d}/configDel`,e):m.configs.delete(e),f.$emit(e,t)}))}))}))),n})),o.request.forEach((t=>s.interceptors.request.use[Array.isArray(t)?"apply":"call"](s,t))),o.response.forEach((t=>s.interceptors.response.use[Array.isArray(t)?"apply":"call"](s,t))),t.prototype.$http=s}};