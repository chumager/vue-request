import merge from"lodash.merge";import mitt from"mitt";export default{install(t,e){const o=merge({},{axiosDefaults:{timeout:12e4,retry:3,withCredentials:!0,timeoutFactor:1.5},withXHR:!0,componentName:"Loading",status:{},fallBack(){alert(this.fallBackText)},fallBackText:"Hubo un problema al comunicarse con el servicio, por favor revise su conexión o reintente más tarde",fallBackTimeOut:15e3,request:[],response:[]},e),{axios:s,axiosDefaults:r,fallBack:a,componentName:n,store:i,storeName:c}=o;if(!s)throw new Error("This plugins needs an axios instance assigned as 'axios'");o.withXHR&&(s.defaults.headers.common["X-Requested-With"]="XMLHttpRequest"),merge(s.defaults,r);const l=t=>{t.loading=!0,t.loadCount++},u=t=>{t.loadCount--,t.loadCount<=0&&(t.loadCount=0,t.loading=!1)},f={loading:!1,loadCount:0,block:!1,configs:new Map},m=mitt(),d=c||"request";if(i){if(i.hasModule(d))throw new Error(`vue-request has store but "${d}" already exists, plase change storeName in options`);i.registerModule(c||"request",{namespaced:!0,state:f,mutations:{start:l,stop:u,configSet(t,{key:e,config:o}){t.configs.set(e,o)},configGet:(t,e)=>t.configs.get(e),configDel:(t,e)=>t.configs.delete(e),lock(t,e){t.lock=e}}})}n&&t.component(n,(async()=>({name:n,props:{transition:{type:String,default:"fade"},color:{type:String,default:"rgba(255, 255, 255, 0.5)"}},computed:{state:()=>i?i.state[d]:f},template:'\n            <transition name={transition}>\n              <div v-show="state.loading" class="__ITDModal" :style="{\'background-color\': color}">\n                <slot>\n                  <h1>Waiting slot here</h1>\n                </slot>\n              </div>\n            </transition>'})));s.interceptors.request.use((t=>(t.noBlock||(i?i.commit(`${d}/start`):l(f)),t.try=t.try||1,t))),s.interceptors.request.use((t=>{const e=i?.getters?.["Config/getLocale"];return e&&(t.headers={...t.headers,"X-Locale":e}),t})),s.interceptors.response.use((t=>(i?i.commit(`${d}/stop`):u(f),t.body=t.data,t)),(async t=>{const{config:e,response:r}=t;if(e.try++,e.timeout*=e.timeoutFactor,e.noBlock||(i?i.commit(`${d}/stop`):u(f)),r){if(r.body=r.data,`${r.status}`in o.status){if("retry"!==o.status[`${r.status}`]){if("function"==typeof o.status[r.status])return o.status[r.status].call(s,e,r);throw new Error(`Trap for ${r.status} is neither "retry" nor function`)}if(e.try<=e.retry)return s(e)}throw t}if(e.try<=e.retry)return s(e);e.try=1;let n=new Promise((t=>{const{url:o,method:s,params:r,body:a}=e;let n=`${o}${s}${JSON.stringify(r)}${JSON.stringify(a)}`;i?i.commit(`${d}/configSet`,{key:n,config:e}):f.configs.set(n,e),m.once(n,(e=>{t(e)}))}));if(!(i?i.state[d].lock:f.lock)){i?i.commit(`${d}/lock`,!0):f.lock=!0,await a(t),i?i.commit(`${d}/lock`,!1):f.lock=!1;let{configs:e}=i?i.state[d]:f;e.forEach((async(t,e)=>{const o=await s(t);i?i.commit(`${d}/configDel`,e):f.configs.delete(e),m.emit(e,o)}))}return n})),o.request.forEach((t=>s.interceptors.request.use[Array.isArray(t)?"apply":"call"](s,t))),o.response.forEach((t=>s.interceptors.response.use[Array.isArray(t)?"apply":"call"](s,t))),t.config.globalProperties.$http=s}};